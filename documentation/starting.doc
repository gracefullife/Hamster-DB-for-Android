/*
 * Copyright (C) 2005-2009 Christoph Rupp (chris@crupp.de).
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or 
 * (at your option) any later version.
 *
 * See files COPYING.* for License information.
 */
/*! \page starting Getting started - The hamsterdb Tutorial

Christoph Rupp 
chris@hamsterdb.com


<h1>The hamsterdb Embedded Storage Tutorial</h1>

A Tutorial Book for hamsterdb Embedded Storage.

Copyright &copy; 2007-2010 Christoph Rupp

\section tut_preamble Preamble

This tutorial is a WORK IN PROGRESS. Do not consider it as a finished
document.

Feedback and comments are always welcome. Please send them to
<a  href="mailto:contact@hamsterdb.com">contact@hamsterdb.com</a>.

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with Invariant
Sections being &quot;The GNU Free Documentation License&quot;, with
no Front- Cover Texts, and with no Back-Cover Texts. A copy of the
license is included in the section entitled &quot;GNU Free
Documentation License&quot;.

\section tut_TOC Table of Contents

<ul>
<li>\ref tut_introduction Introduction
	<ul>
	<li>\ref tut_what_is_hamsterdb What is hamsterdb?	
	<li>\ref tut_Material_Covered		Material Covered	
	<li>\ref tut_Conventions_Used_in_this_Tutorial		Conventions Used in this Tutorial	
	<li>\ref tut_More_Documentation_on_hamsterdb_Embedded_Storage		More Documentation on hamsterdb	
	<li>\ref tut_Obtaining_the_Most_Recent_Versions		Obtaining the Most Recent Versions	
	<li>\ref tut_hamsterdb_Embedded_Storage_Licensing	hamsterdb Licensing	
	</ul>
<li>\ref tut_Getting_Started	Getting Started	
	<ul>
	<li>\ref tut_Building_for_UNIX_POSIX_systems		Building for UNIX/POSIX systems	
	<li>\ref tut_Building_for_Microsoft_Windows		Building for Microsoft Windows	
	<li>\ref tut_Porting_hamsterdb_to_Other_Platforms		Porting hamsterdb to Other Platforms	
	</ul>
<li>\ref tut_Creating_a_Database	Creating a Database	
	<ul>
	<li>\ref tut_Creating_an_In-Memory_Database		Creating an In-Memory Database	
	<li>\ref tut_Creating_a_Record_Number_Database		Creating a Record Number Database	
	</ul>
<li>\ref tut_Opening_a_Database	Opening a Database	
<li>\ref tut_Changing_the_Default_Key_Sorting	Changing the Default Key Sorting	
	<ul>
	<li>\ref tut_The_Prefix_Comparison_Function		The Prefix Comparison Function	
	</ul>
<li>\ref tut_Inserting_Database_Items	Inserting Database Items	
<li>\ref tut_Deleting_Database_Items	Deleting Database Items	
<li>\ref tut_Looking_up_Database_Items	Looking up Database Items	
<li>\ref tut_Working_with_Partial_Access	Working with Partial Access
<li>\ref tut_Working_with_Database_Cursors	Working with Database Cursors	
	<ul>
	<li>\ref tut_Creating_a_Database_Cursor		Creating a Database Cursor	
	<li>\ref tut_Moving_Database_Cursors		Moving Database Cursors	
	<li>\ref tut_Inserting_Database_Items_with_Cursors		Inserting Database Items with Cursors	
	<li>\ref tut_Looking_up_Database_Items_with_Cursors		Looking up Database Items with Cursors	
	<li>\ref tut_Overwriting_Database_Items_with_Cursors		Overwriting Database Items with Cursors	
	<li>\ref tut_Deleting_Database_Items_with_Cursors		Deleting Database Items with Cursors	
	<li>\ref tut_Cloning_a_Database_Cursor		Cloning a Database Cursor	
	<li>\ref tut_Closing_a_Database_Cursor		Closing a Database Cursor	
	</ul>
<li>\ref tut_Closing_a_Database	Closing a Database	
<li>\ref tut_Working_with_Database_Environments		Working with Database Environments	
	<ul>
	<li>\ref tut_Creating_a_new_Environment		Creating a new Environment	
		<ul>
		<li>\ref tut_Creating_In-Memory_Environments			Creating In-Memory Environments	
		</ul>
	<li>\ref tut_Opening_an_Environment		Opening an Environment	
	<li>\ref tut_Creating_a_Database_in_an_Environment		Creating a Database in an Environment	
	<li>\ref tut_Opening_a_Database_in_an_Environment		Opening a Database in an Environment	
	<li>\ref tut_Renaming_a_Database_in_an_Environment		Renaming a Database in an Environment	
	<li>\ref tut_Removing_a_Database_from_an_Environment		Removing a Database from an Environment	
	<li>\ref tut_Closing_an_Environment		Closing an Environment	
	</ul>
<li>\ref tut_Working_with_Duplicate_Keys	Working with Duplicate Keys	
	<ul>
	<li>\ref tut_Enabling_Duplicate_Keys		Enabling Duplicate Keys	
	<li>\ref tut_Inserting_Duplicate_Keys		Inserting Duplicate Keys	
	<li>\ref tut_Traversing_Duplicate_Keys		Traversing Duplicate Keys	
	<li>\ref tut_Replacing_Duplicate_Keys		Replacing Duplicate Keys	
	<li>\ref tut_Get_the_Number_of_Duplicate_Keys		Get the Number of Duplicate Keys	
	<li>\ref tut_Deleting_Duplicate_Keys		Deleting Duplicate Keys	
	<li>\ref tut_Duplicate_Keys_order   		Sort order of Duplicate Keys	
	</ul>
<li>\ref tut_Working_with_Transactions	Working with Transactions	
	<ul>
	<li>\ref tut_Transaction_support_in_hamsterdb		Transaction support in hamsterdb	
	<li>\ref tut_Enabling_Transactions		Enabling Transactions	
	<li>\ref tut_Beginning_a_new_Transaction		Beginning a new Transaction	
	<li>\ref tut_Using_Transactions		Using Transactions	
	<li>\ref tut_Committing_a_Transaction		Committing a Transaction	
	<li>\ref tut_Aborting_a_Transaction		Aborting a Transaction	
	</ul>
<li>\ref tut_Approximate_Matching    Approximate Matching
<li>\ref tut_The_CPP_API	The C++ API	
<li>\ref tut_Troubleshooting	Troubleshooting	
</ul>



\section tut_introduction Introduction


\subsection tut_what_is_hamsterdb What is hamsterdb Embedded Storage?


hamsterdb
Embedded Storage (&quot;hamsterdb&quot;) is a lightweight embedded
database engine. Being &quot;lightweight&quot; describes the
strengths and the limitations of hamsterdb. It is very fast, but only
supports a few operations. It is embedded, and therefore does not
have external dependencies as an SQL server. It is simply a database
engine, but not a database management system (DBMS) and it has no
relational functions or other features provided by SQL.


\subsection tut_Material_Covered    Material Covered

This
document applies to hamsterdb Embedded Storage version 1.1.*. The
author will update the tutorial whenever the API changes. However,
the hamsterdb Embedded Storage API is very stable and so this
tutorial should also apply to future versions of hamsterdb Embedded
Storage.

\subsection tut_Conventions_Used_in_this_Tutorial    Conventions Used in this Tutorial

In this
text, a variety of conventions are used to explain the material.
Certain typographical and display elements are used for this purpose.


Any
C/C++ code that is included directly in the text is displayed as: <tt>int
i = 5</tt>. 



Any
operating system commands discussed in the text are displayed as:
<I>make install</I>. 



Operating
system files that are discussed directly in the text are displayed
as: <I>file.txt</I>. 



When a
technical term of particular importance is first introduced and
discussed, it appears in bold font, as: <B>an important term</B>.


Although
the programming examples and declarations usually are C code, the
author sometimes uses the C++ comment operator \c // as an abbreviation.


Source
code snippets are printed in a non-proportional font:


\code 
int 
main(int argc, char **argv)
{
   return printf("hello world\n");
}
\endcode

Please keep these standards in mind while reading
this tutorial.

\subsection tut_More_Documentation_on_hamsterdb_Embedded_Storage    More Documentation on hamsterdb Embedded Storage

This
tutorial is just an add-on to the official API documentation. This
API documentation is available for reading online or downloading as
PDF at <A  HREF="http://www.hamsterdb.com/?page=docn">http://www.hamsterdb.com/documentation</A>.
Unlike this tutorial, it covers the API in full detail. The API
documentation was generated with Doxygen, a source code documentation
tool. It is based on the header file <I>hamsterdb.h</I>, part of the
hamsterdb Embedded Storage source.

\subsection tut_Obtaining_the_Most_Recent_Versions    Obtaining the Most Recent Versions

This
tutorial is always under development. The most recent version of this
document, of the hamsterdb Embedded Storage library and the API
documentation can be found at <A  HREF="http://www.hamsterdb.com/">http://www.hamsterdb.com</A>.

\subsection tut_hamsterdb_Embedded_Storage_Licensing    hamsterdb Embedded Storage Licensing

hamsterdb
Embedded Storage is an open source library licensed under the GNU
General Public License (GPL) 2.0 or 3.0. Commercial licenses are
available. If you download the hamsterdb source files, the GPL
licenses can be found in the file <I>COPYING.GPL2</I> or <I>COPYING.GPL3</I>. The GPL is a viral license. In plain English, it
says that you are only allowed to link against GPL libraries if your
own sources are also released under the GPL. Please read those
license terms carefully. If they are not acceptable to you, then
commercial licenses can be obtained at
<A  HREF="http://www.hamsterdb.com/store">http://www.hamsterdb.com/store</A>.

\section tut_Getting_Started    Getting Started

This
tutorial demonstrates the use of hamsterdb Embedded Storage. It will
show how to create or open a Database, insert items, look them up and
delete them. It will also demonstrate the use of Database Cursors to
enumerate all items and to insert or delete items using Cursors. But
before hamsterdb can be used, it has to be configured, compiled and
installed. These steps are also described in this chapter.


hamsterdb
Embedded Storage is written in ANSI-C and thus can be compiled on
nearly every available C compiler. 


\subsection tut_Building_for_UNIX_POSIX_systems    Building for UNIX/POSIX systems

hamsterdb
uses the GNU autotools for the build process, therefore compiling and
installing is as simple as it can get. After downloading the sources,
unpack them with the following command:


$<I> tar
-zxvf hamsterdb-v.v.v.tar.gz</I>


This
command creates a subdirectory hamsterdb-v.v.v with all sources.
Change to this directory:


$ <I>cd
hamsterdb-v.v.v</I>


Now run
<I>./configure, make</I> and <I>make install</I> to build and install
the libraries and header files. Please note that you usually need
root privileges to install the header files and libraries. Also note
that you can change the compiler settings by adding flags to
<I>./configure</I>; run .<I>/configure --help</I> for a list of all
available options.


$
<I>./configure</I>


$ <I>make</I>


Now
change user to root:


$ <I>su</I>


$ <I>make
install</I>

\subsection tut_Building_for_Microsoft_Windows    Building for Microsoft Windows

The
hamsterdb package includes Solution files for Microsoft Visual C++
5.0 (Visual Studio 8). A free Express Edition with limited
functionality can be downloaded from Microsoft's website. See
<A  HREF="http://msdn.microsoft.com/vstudio/express/visualc/download">http://msdn.microsoft.com/vstudio/express/visualc/download</A>.


Additionally,
you can download prebuilt libraries for Win32 from
<A  HREF="http://www.hamsterdb.com/?page=download">http://www.hamsterdb.com/download</A>.


To
compile hamsterdb, unpack the hamsterdb sources and open the Solution
file in Visual Studio 8. It can be found in the subdirectory <I>win32</I>.
It contains several projects: some examples, the <B>dll</B> project
(to build a dynamic library) and the <B>lib</B> project (to build a
static library). Build one (or both) of those projects to create your
own hamsterdb library. Note that you will need <A  HREF="http://cppunit.sourceforge.net/">cppunit</A>
if you want to compile and run the unit tests.

\subsection tut_Porting_hamsterdb_to_Other_Platforms    Porting hamsterdb Embedded Storage to Other Platforms

Compiling
hamsterdb without the provided autoconf or Visual Studio files is
easy. There are a few preprocessor macros which are mandatory, and
some others which are optional. They are described in the <I>README</I>
file of the hamsterdb source distribution.


If you
want to port hamsterdb to another operating system or hardware
platform, you will most likely have to make some modifications. All
operating system-specific functions are declared in <I>src/os.h</I>
and defined in either <I>src/os_win32.c</I> or <I>src/os_posix.c</I>.
Please get in touch with the author of hamsterdb to get help with
these topics.

\section tut_Creating_a_Database    Creating a Database

The API
of hamsterdb is simple to use. In this example, we create a new
Database and later insert some values, look them up and then delete
them again. 



If you
want to see a sample code you may find the file <I>samples/db1.c</I>
(or <I>samples/db6.cpp</I>, if you prefer C++) of interest.


Creating
a new Database is a two-step process. Firstly, you must allocate a
Database handle with \ref ham_new.
Secondly, use this handle to create a Database file with \ref ham_create.
The functions are declared in <I>hamsterdb.h</I> as follows:


\code
ham_status_t
ham_new(ham_db_t **db);

ham_status_t
ham_create(ham_db_t *db, const char *filename, ham_u32_t flags,
           ham_u32_t mode);

ham_status_t
ham_create_ex(ham_db_t *db, const char *filename, ham_u32_t flags,
              ham_u32_t mode, ham_parameter_t *param);
\endcode

\ref ham_create supports many options, and the extended version 
\ref ham_create_ex supports even more. However, normally none of them are 
important, and you usually don't need to specify flags, page sizes, key sizes 
and cache sizes. If you nevertheless want to know their meanings, refer
to the API documentation for \ref ham_create and \ref ham_create_ex.
Also, the \ref faq "FAQ" answers questions about the page size, key 
size and cache size.


The \c mode
specifies the file access rights for the newly created file. On Linux
and Unix, they are  identical to the parameter you would give to the
<I>chmod</I> command to change the access rights. If you do not know
what to specify, an (octal) 0664 might be ok for you - this gives
read/write-rights to your own user and all users in the same group,
and read-only rights to anyone else. 



On
Microsoft Windows, the \c mode
parameter is ignored.


\ref ham_create_ex
supports variable length parameter lists. These lists are arrays of
type \ref ham_parameter_t ,
and each parameter has two members: an identifier of this parameter,
and the value. Here is the declaration of \ref ham_parameter_t
(copied from <I>include/ham/hamsterdb.h</I>):


\code
typedef struct
{
    ham_u32_t name;
    ham_u64_t value;
} ham_parameter_t;
\endcode

Here is an example on how to use parameter lists
(in this case, all allowed parameters for \ref ham_create_ex
are specified):


\code
ham_parameter_t parameters[]={
  { HAM_PARAM_KEYSIZE, 15 },
  { HAM_PARAM_CACHESIZE, 1024*128 },
  { HAM_PARAM_PAGESIZE, 1024*4 },
  { 0, 0 }  /* the terminating element! */
};
\endcode

Here's the code to create a new Database file.

\code
#include <stdio.h>  // for printf
#include <stdlib.h> // for exit
#include <ham/hamsterdb.h>

int 
main(int argc, char **argv)
{
   ham_status_t st;
   ham_db_t *db;
   if ((st=ham_new(&db))!=HAM_SUCCESS) {
        printf("ham_new failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }

    if ((st=ham_create(db, "test.db", 0, 0664))!=HAM_SUCCESS) {
        printf("ham_create failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
    // ...
\endcode                                                       

If the call to \ref ham_new was successful, the variable \c db
will hold a valid Database handle. This handle can be used to open or
create Databases.


In the sample code, the \c flags
parameter is 0; no flags are specified. To get a list of all
available flags, either see the <I>hamsterdb.h</I> header file or the
API documentation at <a href="http://hamsterdb.com/documentation">http://hamsterdb.com/documentation</a>.

\subsection tut_Creating_an_In-Memory_Database    Creating an In-Memory Database

In-Memory Databases are not written to disk, but stored in the memory (RAM).
Since RAM access is a lot faster than disk access, In-Memory
Databases offer a big performance boost. On the other hand, the size
of RAM is quite limited compared to the size of modern hard drives.
And there's another disadvantage - if you close the Database, all the
data is lost, because it isn't written to disk.


Nevertheless, because of the speed advantage, In-Memory Databases are great for
temporary, small Databases.


To create an In-Memory Database, call \ref ham_create
with the flag \ref HAM_IN_MEMORY_DB.


Since In-Memory Databases are not written to disk, the \c filename parameter
is ignored and can be set to \c NULL.
Also, note that the cache size (which can be specified with
\ref ham_create_ex) must be 0, and the flag \ref HAM_CACHE_STRICT
is forbidden.


Here is a small snippet showing how to create an In-Memory Database:


\code
if ((st=ham_create(db, NULL, HAM_IN_MEMORY_DB, 0))!=HAM_SUCCESS) {
    printf("ham_create failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode


\subsection tut_Creating_a_Record_Number_Database    Creating a Record Number Database

Record Number Databases automatically assign keys in ascending order to
newly inserted Database items. This can be compared to the
&quot;auto-increment&quot; column in an SQL database. The first
item to be inserted gets the key &quot;1&quot;, the second gets
&quot;2&quot;, the third &quot;3&quot; etc. 


These keys are automatically assigned by hamsterdb. Therefore, when
inserting items to a Record Number Database, \ref ham_insert
and \ref ham_cursor_insert
expect either &quot;empty&quot; keys (with size 0 and
data pointing to NULL), or a user-allocated 8-byte key. The file
<I>samples/db4.c</I> demonstrates the use of Record Number Databases.


To create a Record Number Database, call \ref ham_create
with the flag \ref HAM_RECORD_NUMBER.


Here is a small snippet showing how to create a Record Number Database:


\code
if ((st=ham_create(db, "filename.db", HAM_RECORD_NUMBER, 0))!=HAM_SUCCESS) {
    printf("ham_create failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

\section tut_Opening_a_Database    Opening a Database

Opening an existing Database is also a two-step
process. First, you have to allocate a Database handle, and then you
open the Database file. We already know how to allocate the handle
(\ref ham_new).
To open the Database file, you may use one of two API functions:
\ref ham_open or the extended version \ref ham_open_ex.

\code
ham_status_t
ham_open(ham_db_t *db, const char *filename, ham_u32_t flags);

ham_status_t
ham_open_ex(ham_db_t *db, const char *filename, ham_u32_t flags, 
            ham_parameter_t *parameter);
\endcode

Similarly to \ref ham_create and \ref ham_create_ex,
you usually do not need to specify the cache size and flags. However,
there is one flag which might be useful from time to time:
\ref HAM_READ_ONLY .
This flag opens the Database for read-only access, and all write
modifications (inserting or deleting items) fail with the error
\ref HAM_DB_READ_ONLY.


\ref ham_open_ex also uses variable length parameter lists. Currently, only 
the cache size can be specified as a parameter (\ref HAM_PARAM_CACHESIZE).
See the section &quot;Creating a Database&quot; on how to use and
initialize parameter lists. 


\section tut_Changing_the_Default_Key_Sorting Changing the Default Key Sorting

hamsterdb treats keys and records as byte arrays; it does not associate
a &quot;schema&quot; with the keys, i.e. it does not know whether your keys
are strings, integer values or complex structures.

When you insert keys and records to the Database,
all keys are automatically sorted. The default sort function is based
on memcmp and sorts the keys' byte arrays in a ascending order,
starting with the &quot;smallest&quot; value.

If such a sort order is not feasible for your
data, you can overwrite the sort function. You have to write a
callback function and register this function with \ref ham_set_compare_func.
Keep in mind that you have to do this whenever you create and open a
Database, since the comparison function is not stored in the Database
itself. Registering your comparison function has to take place before
you create or open the Database, and after you allocate the Database
handle with \ref ham_new.

\code
typedef int (*ham_compare_func_t)(ham_db_t *db,
                const ham_u8_t *lhs, ham_size_t *lhs_length,
                const ham_u8_t *rhs, ham_size_t *rhs_length);
\endcode

The callback function receives four parameters:
the &quot;left-hand side&quot; and the &quot;right-hand side&quot;
of the compare operation. It returns -1 if the left-hand side is
smaller than the right-hand side, it returns 0 if both keys are
equal, or +1 if right-hand side is smaller than left-hand side. 

The following code snippet casts the keys to
integer values and compares those integers. Please note that the
layout of integers in memory is endian-dependent. If you copy your
Database from an Intel PC to an IBM PowerPC system, you will
encounter strange behaviour, because the sorting will fail. To be on
the safe side, you should always explicitly set the endianness of
your data, i.e. by using \c ntohs
or similar functions provided by your environment (you can also use
the hamsterdb endian macros defined in <I>src/endian.h</I>.) In this
example, the endianness of the data is ignored.

\code
#include <stdio.h>  // for printf
#include <stdlib.h> // for exit
#include <ham/hamsterdb.h>

static int
my_int_compare(ham_db_t *db, ham_u8_t *lhs, ham_size_t lhs_size,
               ham_u8_t *rhs, ham_size_t rhs_size)
{
    int nlhs=*(int *)lhs;
    int nrhs=*(int *)rhs;
    if (nlhs<nrhs) return -1;
    if (nrhs>nlhs) return +1;
    return 0;
}

int 
main(int argc, char **argv)
{

    ham_status_t st;
    ham_db_t *db;
    if ((st=ham_new(&db))!=HAM_SUCCESS) {
        printf("ham_new failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
    if ((st=ham_set_compare_func(db, my_int_compare))!=HAM_SUCCESS) {
        printf("ham_set_compare_func failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
    if ((st=ham_create(db, "test.db", 0, 0664))!=HAM_SUCCESS) {
        printf("ham_create failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
    // ...
\endcode

\subsection tut_The_Prefix_Comparison_Function    The Prefix Comparison Function

If the comparison function is overwritten, it
might be necessary to also change the prefix comparison function.

hamsterdb stores keys in a B+Tree structure. This structure can only manage
keys with a limited, constant length. If your key extends this length, it is
called a &quot;extended key&quot;. Such keys are then split - one part is
stored in the B+Tree index, the remainder is stored in an overflow area.

The size of the prefix in the B+Tree is 21 bytes by default, but can be
overwritten with the parameter \ref HAM_PARAM_KEYSIZE
in \ref ham_create_ex.

When hamsterdb compares two keys, it will first try to compare the prefixes 
only, because then it can avoid loading the overflow area and thus save 
performance. This prefix comparison can be overwritten with a custom compare 
function.

The prefix comparison function is always called
when one (or both) keys are extended keys, but are loaded only
partially.

The default prefix comparison function is based on
\c memcmp.
To disable the prefix comparison, call \ref ham_set_prefix_compare_func
and set the function pointer to \c NULL:

\code
ham_set_prefix_compare_func(db, NULL);
\endcode

You can use this function to specify your own prefix comparison. 
For details, please refer to the API documentation of 
\ref ham_set_prefix_compare_func in <I>include/ham/types.h</I>.

\section tut_Inserting_Database_Items    Inserting Database Items

Unlike a relational database management system
(RDBMS), hamsterdb does not know about the layout of your keys or
records. In a RDBMS, the type of a column is specified in the SQL
statement which creates the colum. For hamsterdb, a key and a record
are just two byte arrays of variable length.

To insert such a key/record pair, the caller has
to create two structures - one for the key and one for the record,
initialize them and then call \ref ham_insert.

The second parameter of \ref ham_insert is a Transaction handle; if you do not
use Transactions, then set the argument to \c NULL. Transactions are covered
in a later chapter.

\code
ham_status_t
ham_insert(ham_db_t *db, ham_txn_t *txn, ham_key_t *key,
           ham_record_t *record, ham_u32_t flags);
\endcode

It is important that you initialize the structures
with zeroes before setting the key values. The following code
initializes a key/record pair with the strings 
&quot;color&quot;/&quot;green&quot; and inserts them.

\code
ham_key_t key;
ham_record_t record;

memset(&key, 0, sizeof(key));
memset(&record, 0, sizeof(record));

key.data="color";
key.size=strlen(key.data)+1; /* +1 for the terminating zero-byte */
record.data="green";
record.size=strlen(record.data)+1; /* +1 for the terminating zero-byte */

if ((st=ham_insert(db, NULL, &key, &record, 0))!=HAM_SUCCESS) {
    printf("ham_insert failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

\ref ham_insert fails and returns error \ref HAM_DUPLICATE_KEY
if an item with this key already exists. To overwrite an existing
item, use the flag \ref HAM_OVERWRITE.

\section tut_Deleting_Database_Items    Deleting Database Items

The API function \ref ham_erase deletes a Database item. It receives four 
parameters: a Database handle, a Transaction handle, the key of the item 
which will be deleted and \c flags. The \c flags are currently not used 
and should be set to \c NULL.

The second parameter of \ref ham_erase is a Transaction handle; if you do not
use Transactions, then set the argument to \c NULL. Transactions are covered
in a later chapter.

\code
ham_status_t
ham_erase(ham_db_t *db, ham_txn_t *txn, ham_key_t *key, ham_u32_t flags);
\endcode


The following example deletes the item with the key &quot;color&quot;:

\code
ham_status_t st;
ham_key_t key;

memset(&key, 0, sizeof(key));
key.data="color";
key.size=strlen(key.data)+1; /* +1 to include the terminating zero */

if ((st=ham_erase(db, NULL, &key, 0))!=HAM_SUCCESS)  {
    printf("ham_erase failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

If you followed the tutorial, the item &quot;color&quot;/&quot;green&quot; 
is now deleted from the Database. A subsequent \ref ham_find
on that value will fail with \ref HAM_KEY_NOT_FOUND.

If you try to delete an item which does not exist,
hamsterdb will return \ref HAM_KEY_NOT_FOUND.

\section tut_Looking_up_Database_Items    Looking up Database Items

The function for looking up Database items is called \ref ham_find.
This function receives five parameters, of which one (\c flags)
is reserved and always set to \c NULL .
The third parameter (\c key) receives a pointer to a full \ref ham_key_t
structure. If the key is found, the record of this key is returned in
parameter four (\c record).

The second parameter of \ref ham_find is a Transaction handle; if you do not
use Transactions, then set the argument to \c NULL. Transactions are covered
in a later chapter.

\code
ham_status_t
ham_find(ham_db_t *db, ham_txn_t *txn, ham_key_t *key,
         ham_record_t *record, ham_u32_t flags);
\endcode

The following example looks up the key &quot;color&quot;:

\code
ham_status_t st;
ham_key_t key;
ham_record_t record;

memset(&key, 0, sizeof(key));
memset(&record, 0, sizeof(record));
key.data="color";
key.size=strlen(key.data)+1; /* +1 for the terminating zero-byte */

if ((st=ham_find(db, NULL, &key, &record, 0))!=HAM_SUCCESS) {
    printf("ham_find failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

If you followed the tutorial, \ref ham_find
returns error \ref HAM_KEY_NOT_FOUND, because we deleted the key
&quot;color&quot; in the previous chapter. If you did NOT delete
the key, \c record.data will now point to the string &quot;green&quot;
and  \c record.size will be 6.

Please bear in mind that  \c record.data
is a temporary pointer which is allocated by hamsterdb. Other calls
to hamsterdb API functions can overwrite this pointer. If you want to
avoid this behaviour, you can allocate the pointer on your own and
set the flag \ref HAM_RECORD_USER_ALLOC.
In this case, it is the programmer's responsibility to make sure that
the allocated memory is actually large enough for the data!

\code
memset(&record, 0, sizeof(record));
record.flags=HAM_RECORD_USER_ALLOC;
record.data=malloc(6);

if ((st=ham_find(db, NULL, &key, &record, 0))!=HAM_SUCCESS) {
    // ...
\endcode

\section tut_Working_with_Partial_Access	Working with Partial Access

(Implemented in version 1.1.3)<br />
In some scenarios, inserting or looking up a record in one single
operation may be difficult - i.e. if the record is too huge for the system 
limitations. For such cases, hamsterdb offers "Partial Access" to a record.

With Partial Access, records can be read or written in several smaller steps.
If the flag @ref HAM_PARTIAL is specified in @ref ham_insert or @ref ham_find
(or one of the corresponding cursor functions), then hamsterdb will 
evaluate the fields <i>record->partial_offset</i> and
<i>record->partial_size</i>.

When writing a partial record, hamsterdb will write <i>record->partial_size</i>
bytes of the record data at offset <i>record->partial_offset</i>. The full 
record size will always be given in <i>record->size</i>. When a record is 
overwritten (see @ref HAM_OVERWRITE) with a different record->size, the 
record will grow or shrink.

When writing with an invalid combination (the sum of partial_offset 
+ partial_size exceeds the total record size), hamsterdb will return 
@ref HAM_INV_PARAMETER.

When reading a partial record, hamsterdb will read <i>record->partial_size</i>
bytes of the record data starting at offset <i>record->partial_offset</i>. The
data will be stored in <i>record->data</i>. The size of the retrieved data
is stored in <i>record->size</i>.

When reading a part of a record, and the partial_offset exceeds the total 
record size, hamsterdb will return @ref HAM_INV_PARAMETER. If the sum of 
partial_offset + partial_size exceeds the total record size, hamsterdb
will limit the partial_size and return the read size in <i>record->size</i>.

\section tut_Working_with_Database_Cursors    Working with Database Cursors

A Database Cursor (C++ programmers may prefer the
term &quot;iterator&quot;) is a pointer to a Database item. You can
use it to traverse the Database and to enumerate all items. You can
enumerate items from front to back or vice versa. You can also use a
Cursor to look up a key, or to overwrite, delete and insert items.

This chapter explains how to create and use Database Cursors.

\subsection tut_Creating_a_Database_Cursor    Creating a Database Cursor

Cursors are managed using a \ref ham_cursor_t
structure. You allocate such a Cursor structure with the
\ref ham_cursor_create method. The first parameter is always the \ref ham_db_t
handle of the Database on which this Cursor operates. The third
third parameter is not yet used; always set it to \c 0. Here is the 
declaration of the function:

The second parameter of \ref ham_cursor_create is a Transaction handle; if you 
do not use Transactions, then set the argument to \c NULL. Transactions are 
covered in a later chapter.

\code
ham_status_t
ham_cursor_create(ham_db_t *db, ham_txn_t *txn, 
            ham_u32_t flags, ham_cursor_t **cursor);
\endcode
    

And
here is an example of the usage; it creates a Cursor which can
operate on the Database \c db:	

\code
ham_cursor_t *cursor;

ham_status_t st;
if ((st=ham_cursor_create(db, NULL, 0, &cursor))) {
    // ...
\endcode

After creation, the new Cursor does not point to any item in the Database.	

\subsection tut_Moving_Database_Cursors    Moving Database Cursors

The new Cursor is not yet of much use. Since it
does not point to an item, some operations (i.e. deleting the current
item) will fail. To use the Cursor, we have to position it on an item.

With \ref ham_cursor_move, you can move the Cursor to the first, last, 
next or previous item in the Database. Here is the declaration of the function:

\code
ham_status_t
ham_cursor_move(ham_cursor_t *cursor, ham_key_t *key, 
            ham_record_t *record, ham_u32_t flags);
\endcode
        
This function sets the Cursor to the type which is specified in the flags.
This can be one of \ref HAM_CURSOR_FIRST,
\ref HAM_CURSOR_LAST, \ref HAM_CURSOR_NEXT or \ref HAM_CURSOR_PREVIOUS.

If you do not specify any direction, the Cursor will remain at the
current position. (This behaviour can be used to retrieve the key or record
of the current item.)

If a Cursor does not point to a Database item, and you move it to
\ref HAM_CURSOR_NEXT (or \ref HAM_CURSOR_PREVIOUS),
hamsterdb will automatically move the Cursor to the first (or last)
element.

The key and record parameters are optional. After moving the Cursor, the
key and the record of the new Database item will be retrieved copied
to key and/or record, if key and/or record are not \c NULL.

This short example creates a Cursor and traverses the Database from the
first to the last element, printing every Database key. (It is
assumed that the key is of type \c char *, and can be printed with 
\c printf(&quot;%s&quot;)). Since the record of each item is not 
used, it is not retrieved.

\code
ham_cursor_t *cursor;
ham_status_t st;
ham_key_t key;

if ((st = ham_cursor_create(db, NULL, 0, &cursor)))
    ; // handle error

while (1) {
    st = ham_cursor_move(cursor, &key, NULL, HAM_CURSOR_NEXT);
    if (st != HAM_STATUS_OK) {
        if (st==HAM_KEY_NOT_FOUND)
            break; // reached the end of the database
        else
           printf("database error: %d\n", st);
        exit(-1);
    }
    
    printf("key: %s\n", (char *)key.data);
}
\endcode

Since we are only interested in the keys of the Database items, we do not
request the record. Therefore, the third parameter of \ref ham_cursor_move
is set to \c NULL.

\ref ham_cursor_move will return \ref HAM_KEY_NOT_FOUND
if the Cursor points to the last item in the Database and the next
item is requested, or if the Cursor points to the first item and the
previous item is requested.

\subsection tut_Inserting_Database_Items_with_Cursors    Inserting Database Items with Cursors

\ref ham_cursor_insert behaves the same as \ref ham_insert.
If the item is inserted successfully, the Cursor will point to the
new item. Otherwise, the Cursor is not modified. Here is the
declaration of \ref ham_cursor_insert:

\code
ham_status_t
ham_cursor_insert(ham_cursor_t *cursor, ham_key_t *key, 
            ham_record_t *record, ham_u32_t flags);
\endcode
            
And here is an example of the usage; it returns the key &quot;hello&quot;
and the record &quot;world&quot;:	

\code
ham_key_t key;
ham_record_t record;
ham_status_t st;

memset(&key, 0, sizeof(key));
key.data="hello";
key.size=strlen(key.data)+1; /* +1 for the terminating zero-byte */

memset(&record, 0, sizeof(record));
record.data="world";
record.size=strlen(record.data)+1; /* +1 for the terminating zero-byte */

if ((st=ham_cursor_insert(cursor, &key, &record, 0))) {
    // ...
\endcode

\subsection tut_Looking_up_Database_Items_with_Cursors    Looking up Database Items with Cursors

You can use Cursors to search for Database records. The function 
\ref ham_cursor_find tries to search for a key, and positions the 
Database cursor on the item with this key. If the item is not found, the 
Cursor is not modified. The \c flags parameter is unused - set it to \c 0.

\code
ham_status_t
ham_cursor_find(ham_cursor_t *cursor, ham_key_t *key, ham_u32_t flags);
\endcode
        
When the Cursor points to a Database item, you can delete the item (with
\ref ham_cursor_erase), overwrite the record (with \ref ham_cursor_overwrite),
or just fetch the record (with \ref ham_cursor_move).
The following code demonstrates how to fetch the record with
\ref ham_cursor_move:

\code
ham_key_t key;
ham_record_t record;
ham_status_t st;

memset(&key, 0, sizeof(key));
key.data="hello";
key.size=strlen(key.data)+1; /* +1 for the terminating zero-byte */

memset(&record, 0, sizeof(record));

if ((st = ham_cursor_insert(cursor, &key, &record, 0)))
    // handle error
if ((st=ham_cursor_move(cursor, 0, &record, 0)))
    // handle error
\endcode

Note that although we call \ref ham_cursor_move,
the Cursor is not moved at all because we have not specified a
direction flag. Therefore, \ref ham_cursor_move
just returns the record of the current item.

\subsection tut_Overwriting_Database_Items_with_Cursors    Overwriting Database Items with Cursors

To overwrite the record of the current item, call
\ref ham_cursor_overwrite
with a pointer to a \ref ham_record_t
structure which contains the new record. The third parameter, \c flags ,
is unused; set it to \c 0 .


\code
ham_status_t
ham_cursor_overwrite(ham_cursor_t *cursor, ham_record_t *record, ham_u32_t flags);
\endcode
                

If you try to overwrite an item while the Cursor
does not point to an item, hamsterdb returns \ref HAM_CURSOR_IS_NIL.

\subsection tut_Deleting_Database_Items_with_Cursors    Deleting Database Items with Cursors

To delete a record using a Cursor, position the
Cursor on the record you want to delete, then call \ref ham_cursor_erase.
The third parameter, \c flags, is unused; set it to \c 0.

\code
ham_status_t
ham_cursor_erase(ham_cursor_t *cursor, ham_u32_t flags);
\endcode

If you try to delete an item, but the Cursor does
not point to an item, hamsterdb returns \ref HAM_CURSOR_IS_NIL.

If the delete operation was successful, the Cursor
will be uninitialized and not point to any item at all.

\subsection tut_Cloning_a_Database_Cursor    Cloning a Database Cursor

hamsterdb provides a function for cloning an existing Cursor. 
\ref ham_cursor_clone creates an exact copy of a cursor which points 
to the same Database item as the original Cursor.

\code
ham_status_t
ham_cursor_clone(ham_cursor_t *src, ham_cursor_t **dest);
\endcode

\subsection tut_Closing_a_Database_Cursor    Closing a Database Cursor

When you finished working with a Database Cursor,
you have to close and free it. This will prevent memory leaks. All
Cursors must be closed before the Database is closed.

\code
ham_status_t
ham_cursor_close(ham_cursor_t *cursor);
\endcode


\section tut_Closing_a_Database    Closing a Database

Database handles are closed with \ref ham_close.
This function implicitly calls \ref ham_flush ,
writes the modified file to disk and closes the file handle. If you
forget to call this function, you will lose your data and the
Database may be corrupted!


Currently, one flag is supported: \ref HAM_AUTO_CLEANUP
automatically closes all open Cursors of this Database. Otherwise you
have to call \ref ham_cursor_close on each opened Cursor to
avoid memory leaks.

\code 
ham_status_t
ham_close(ham_db_t *db, ham_u32_t flags);
\endcode


Note that this function does not delete the Database handle, which was
allocated with \ref ham_new.
The Database handle is still valid, and you can reuse it to open or
create other Databases.

If you do not want to reuse the Database handle, you have to delete it
with \ref ham_delete.

\code
ham_status_t
ham_delete(ham_db_t *db);
\endcode

The following snippet closes the Database, and automatically closes all 
open Cursors. Then it deletes the Database handle, to avoid memory leaks.

\code
if ((st=ham_close(db, HAM_AUTO_CLEANUP))) {
    printf("ham_close failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
ham_delete(db);
\endcode

\section tut_Working_with_Database_Environments    Working with Database Environments

Sometimes, it is practical to have several
Databases in one physical file. It makes backing up easier, because
only one file has to be copied. Databases that belong together, can
be grouped to one physical file, and the file system is not populated
with too many files. 



This functionality is provided by Database
Environments. A Database Environment can either be file-based or
in-memory based (but not both at the same time). 



The major difference to file-based Databases is
the Database name. So far, each Database had a file name. With Environments, a
Database name is no longer a string, but an unsigned 16 bit wide identifier. 
The values 0 and everything above 0xf000 are reserved.

Environment files have the same format as normal
Database files. it is therefore possible to use a Database file as an
Environment file, and vice versa. When you open an Environment file
with the normal Database functions, hamsterdb will automatically load
the first Database.


The following chapter shows how to create or open
Environments, how to create, open, rename or delete Databases from
Environment files, and anything else you should learn in order to
work with Environments.


For a complete sample on how to use Environments,
see the file <I>samples/env1.c</I> (and <I>
samples/env3.cpp</I> if you prefer
C++). This sample creates two Databases - one for customers,
one for orders. It fills them, and then prints a list of all
customers and their orders.


\subsection tut_Creating_a_new_Environment    Creating a new Environment

Creating a new Environment is a two-step process,
similar to creating a new Database. First, you allocate a new
Environment handle (of type \ref ham_env_t
*), then you create the Environment. The functions are
declared in <I>include/ham/hamsterdb.h</I> as follows:


\code
ham_status_t
ham_new_env(ham_env_t **env);
ham_status_t
ham_env_create(ham_env_t *env, const char *filename, ham_u32_t flags,
           ham_u32_t mode);
ham_status_t
ham_env_create_ex(ham_env_t *env, const char *filename, ham_u32_t flags,
           ham_u32_t mode, ham_parameter_t *param);
\endcode

Again, \ref ham_env_create_ex
expects a variable length parameter list; the parameters
\ref HAM_PARAM_PAGESIZE and \ref HAM_PARAM_CACHESIZE
are supported. See the section &quot;Creating a Database&quot; for
more information about parameter lists and about the mode parameter.


All other parameters are similar to their counterparts \ref ham_create
and \ref ham_create_ex.


Here's the code for creating a hamsterdb Environment:


\code
#include <stdio.h>  // for printf
#include <stdlib.h> // for exit
#include <ham/hamsterdb.h>

int 
main(int argc, char **argv)
{

    ham_status_t st;
    ham_env_t *env;
       
    if ((st=ham_env_new(&env))!=HAM_SUCCESS) {
        printf("ham_env_new failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
    if ((st=ham_env_create(env, "test.db", 0, 0664))!=HAM_SUCCESS) {
        printf("ham_env_create failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
    // ...
\endcode


\subsubsection tut_Creating_In-Memory_Environments    Creating In-Memory Environments

Environments do not have to be file-based, they can also reside in the RAM.

While you gain better performance, it is not
possible to delete existing Databases from an Environment (with
\ref ham_env_erase_db), and you cannot open existing Databases - as soon as 
you close the Database it is gone and there is no way to restore it.


To create an In-Memory Environment, call
\ref ham_env_create with the flag \ref HAM_IN_MEMORY_DB.
Since In-Memory Databases are not written to disk, the \c filename parameter
is ignored and can be \c NULL.
Also, note that the cache size (which can be specified with
\ref ham_env_create_ex) must be \c 0, and the flag \ref HAM_CACHE_STRICT
is forbidden.


Here is a code snippet creating an In-Memory Environment:


\code
    if ((st=ham_env_create(env, NULL, HAM_IN_MEMORY_DB, 0))!=HAM_SUCCESS) {
        printf("ham_env_create failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
\endcode

\subsection tut_Opening_an_Environment    Opening an Environment

The procedure of opening an Environment is again
quite similar to opening a Database. First, an Environment handle is
allocated (\ref ham_env_new), then the file is opened with either 
\ref ham_env_open or the extended version \ref ham_env_open_ex.


\code
ham_status_t
ham_env_open(ham_env_t *env, const char *filename, ham_u32_t flags);

ham_status_t
ham_env_open_ex(ham_env_t *env, const char *filename, ham_u32_t flags,
        ham_parameter_t *param);
\endcode

Again, \ref ham_env_open_ex
expects a variable length parameter list. The only accepted parameter
is the cache size (\ref HAM_PARAM_CACHESIZE).
See the section &quot;Creating a Database&quot; for more information
about parameter lists.


You can specify the flag \ref HAM_READ_ONLY
to open the Environment in read-only mode. In this mode it is not possible
to create new Databases or to rename existing Databases in this
Environment. All write modifications will fail with error \ref HAM_DB_READ_ONLY.


\subsection tut_Creating_a_Database_in_an_Environment    Creating a Database in an Environment

To create a new Database in an Environment, you
need a valid Database handle (allocated with \ref ham_new).
Then call \ref ham_env_create_db with this Database handle.


\code
ham_status_t
ham_env_create_db(ham_env_t *env, ham_db_t *db, ham_u16_t name, 
        ham_u32_t flags, ham_parameter_t *params);
\endcode

The third parameter of \ref ham_env_create_db
is the name of the new Database &ndash; a unique identifier in this
Environment. The values 0 and everything above (including) 0xf000
are reserved and forbidden to use. Here is a short example, copied
from <I>samples/env1.c</I>.


\code
#define DBNAME_CUSTOMER     1

ham_db_t *db;
ham_status_t st;

st=ham_new(&db);
if (st!=HAM_SUCCESS)
    error("ham_new", st);

st=ham_env_create_db(env, db, DBNAME_CUSTOMER, 0, 0);
if (st!=HAM_SUCCESS) {
    printf("ham_env_create_db failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

You can now use the Database handle as you normally do, i.e. for Cursor 
operations or inserting/erasing values etc. To close the Database, use 
\ref ham_close, then delete the Database handle with \ref ham_delete.


\subsection tut_Opening_a_Database_in_an_Environment    Opening a Database in an Environment

To open an existing Database in an Environment, you need a valid Database 
handle (allocated with \ref ham_new). Then call \ref ham_env_create_db
with this Database handle.


\code
ham_status_t
ham_env_open_db(ham_env_t *env, ham_db_t *db, ham_u16_t name, 
        ham_u32_t flags, ham_parameter_t *params);
\endcode

The third parameter of \ref ham_env_open_db
is the name of the new Database. If a Database with this name is not
found, error \ref HAM_DATABASE_NOT_FOUND is returned.


\code
st=ham_env_open_db(env, db, DBNAME_CUSTOMER, 0, 0);
if (st!=HAM_SUCCESS) {
    printf("ham_env_open_db failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

You can now use the Database handle as you
normally do, i.e. for Cursor operations or inserting/erasing values
etc. To close the Database, use \ref ham_close, then delete the Database 
handle with \ref ham_delete.


You can not open the same Database several times.
If you call \ref ham_env_open_db with a Database name which was already 
opened, status code \ref HAM_DATABASE_ALREADY_OPEN is returned.

\subsection tut_Renaming_a_Database_in_an_Environment    Renaming a Database in an Environment

You can rename Databases in an Environment with \ref ham_env_rename_db.
This function is declared as follows:


\code
ham_status_t
ham_env_rename_db(ham_env_t *env, ham_u16_t oldname,
                ham_u16_t newname, ham_u32_t flags);
\endcode

No error occurs if a Database with the original name is already open.

The function returns \ref HAM_DATABASE_NOT_FOUND if the Database with 
the old name is not found, and \ref HAM_DATABASE_ALREADY_EXISTS
if a Database with the new name already exists.

\subsection tut_Removing_a_Database_from_an_Environment    Removing a Database from an Environment

Unlike calls to \ref ham_env_rename_db, \ref ham_env_erase_db
makes sure that the Database, which you want to delete, is not open.
If the Database is still open, error \ref HAM_DATABASE_ALREADY_OPEN
is returned. Otherwise, the Database is deleted from the Environment.
This can be a costly operation, because all the allocated file pages
are moved to the freelist, in order to reuse them at a later stage.


\code
ham_status_t
ham_env_erase_db(ham_env_t *env, ham_u16_t name, ham_u32_t flags);
\endcode

It is not possible to call this function on an In-Memory Environment.
For In-Memory Environments, it is sufficient to just close the
Database with \ref ham_close. This will immediately free all allocated 
memory blocks.


\subsection tut_Closing_an_Environment    Closing an Environment

To close an Environment, use \ref ham_env_close. To delete the memory 
allocated by the \ref ham_env_t handle, use \ref ham_env_delete.

Currently, one flag is supported: \ref HAM_AUTO_CLEANUP
automatically closes all open Databases (and their Cursors) of this
Environment. Otherwise you have to call \ref ham_close
for each opened Database, to avoid memory leaks. Nevertheless you have 
to call \ref ham_delete for each Database handle which was allocated
with \ref ham_new.

\code
ham_status_t
ham_env_close(ham_env_t *env, ham_u32_t flags);

ham_status_t
ham_env_delete(ham_env_t *env);
\endcode

The following code will close the Environment
handle and all associated Database handles. Afterwards, the
Environment handle is deleted to avoid memory leaks:


\code
st = ham_env_close(env, HAM_AUTO_CLEANUP);
if (st != HAM_SUCCESS) {
    printf("ham_env_close failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
ham_env_delete(env);
\endcode

\section tut_Working_with_Duplicate_Keys    Working with Duplicate Keys

Starting with version 0.4.6, hamsterdb supports
duplicate keys. A key is a duplicate of another key if both keys are
equal. Duplicate keys can be used to model 1:n relationships, where
i.e. one customer ID has multiple order IDs. The sample
<I>samples/env2.c</I> demonstrates how to use duplicate keys to map
orders to customers. 

The following section gives an overview on the usage of duplicate keys.

\subsection tut_Enabling_Duplicate_Keys    Enabling Duplicate Keys

Duplicate keys have to be enabled when the Database is created 
with \ref ham_create, \ref ham_create_ex or \ref ham_env_create_db.
The flag is called \ref HAM_ENABLE_DUPLICATES.

\code
if ((st = ham_create(db, "test.db", HAM_ENABLE_DUPLICATES,
                     0664)) != HAM_SUCCESS) {
    printf("ham_create failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

\subsection tut_Inserting_Duplicate_Keys    Inserting Duplicate Keys

To insert a duplicate key, call \ref ham_insert or \ref ham_cursor_insert
with the flag \ref HAM_DUPLICATE.
If you do not specify this flag, and the key already exists, the
status \ref HAM_DUPLICATE_KEY is returned. If the flag is specified, 
but the key does not yet exist, it is inserted just as if the flag was 
not specified.

Note that you can modify the order of the inserted
records by specifying one of the flags \ref HAM_DUPLICATE_INSERT_BEFORE,
\ref HAM_DUPLICATE_INSERT_AFTER, \ref HAM_DUPLICATE_INSERT_FIRST
or \ref HAM_DUPLICATE_INSERT_LAST to \ref ham_cursor_insert.
The default is \ref HAM_DUPLICATE_INSERT_LAST, which is also the behaviour 
of \ref ham_insert.

The following snippet inserts five duplicate keys.



\code
int i;
ham_key_t key;
ham_record_t record;

memset(&key, 0, sizeof(key));
memset(&record, 0, sizeof(record));
key.data="numbers";
key.size=strlen(key.data)+1; /* +1 for the terminating zero-byte */

for (i=0; i<5; i++) {
    record.data=&i;
    record.size=sizeof(i);
    
    if ((st=ham_insert(db, NULL, &key, &record,
            HAM_DUPLICATE))!=HAM_SUCCESS) {
        printf("ham_insert failed: %d (%s)\n", st, ham_strerror(st));
        exit(-1);
    }
}
\endcode


\subsection tut_Traversing_Duplicate_Keys    Traversing Duplicate Keys

Duplicate keys and their records can only be traversed with a Cursor; 
\ref ham_find always returns the first duplicate record. 

The default behaviour of \ref ham_cursor_move is to traverse also all 
duplicate keys. However, duplicate keys can be omitted by specifying the 
flag \ref HAM_SKIP_DUPLICATES, and the Cursor can be forced to only step 
through duplicates with the flag \ref HAM_ONLY_DUPLICATES
(in this case, \ref ham_cursor_move returns \ref HAM_KEY_NOT_FOUND
if the last duplicate key is reached).

The following snippet moves a Cursor to the first
duplicate with the key "numbers", and then traverses all duplicates of 
this key.


\code
memset(&key, 0, sizeof(key));
memset(&record, 0, sizeof(record));
key.data="numbers";
key.size=strlen(key.data)+1; /* +1 for the terminating zero-byte */

if ((st=ham_cursor_find(cursor, &key, 0))!=HAM_SUCCESS)
    ; // handle error

do {
    // fetch the current record, without moving
    if ((st=ham_cursor_move(cursor, 0, &record, 0)!=HAM_SUCCESS)
        ; // handle error
    printf("number: %d\n", *(int *)record->data);
 
    // move to the next duplicate, but do not fetch key or record
} while ((st=ham_cursor_move(cursor, 0, 0, 
            HAM_CURSOR_NEXT|HAM_ONLY_DUPLICATES)!=HAM_SUCCESS);
\endcode




\subsection tut_Replacing_Duplicate_Keys    Replacing Duplicate Keys

The records of a duplicate key can be overwritten
with \ref ham_cursor_overwrite.
There is no difference between overwriting a record of a duplicate
key and a non-duplicate key. If \ref ham_insert
is used with the flag \ref HAM_OVERWRITE,
the first duplicate record is overwritten.




\subsection tut_Get_the_Number_of_Duplicate_Keys    Get the Number of Duplicate Keys

You can always check the number of duplicate keys
with \ref ham_cursor_get_duplicate_count.
Move a Cursor to the key (either with \ref ham_cursor_find
or \ref ham_cursor_move),
and call \ref ham_cursor_get_duplicate_count.
If a key does not have duplicates, \ref ham_cursor_count
will return 1 in its \c count
parameter. Otherwise it returns the number of duplicate keys.


\code
ham_status_t
ham_cursor_get_duplicate_count(ham_cursor_t *cursor, ham_size_t *count, 
        ham_u32_t flags);
\endcode

Here is an example which prints the number of
duplicate keys of the item identified by "numbers".


\code
ham_size_t count;
memset(&key, 0, sizeof(key));
key.data="numbers";
key.size=strlen(key.data)+1; /* +1 for the terminating zero-byte */

if ((st=ham_cursor_find(cursor, &key, 0))!=HAM_SUCCESS)
    ; // handle error

if ((st=ham_cursor_get_duplicate_count(cursor, &count, 0))!=HAM_SUCCESS)
    ; // handle error
printf("key 'numbers' has %d duplicate keys\n", count);
\endcode


\subsection tut_Deleting_Duplicate_Keys    Deleting Duplicate Keys

In this case, \ref ham_erase and \ref ham_cursor_erase
behave differently. \ref ham_erase deletes the key and all duplicate records 
at once. \ref ham_cursor_erase only deletes the duplicate to which it points. 

\code
if ((st=ham_cursor_erase(cursor, 0))!=HAM_SUCCESS)
    ; // handle error
\endcode

\subsection tut_Duplicate_Keys_order   		Sort order of Duplicate Keys	

Per default, when a new duplicate key is inserted, it will appended after
all other duplicates of the same key. 

This behaviour can be overwritten by setting the flag @ref HAM_SORT_DUPLICATES
in combination with @ref HAM_ENABLE_DUPLICATES when creating or opening
the Database. The default sort order will be based on memcpy(2) and can
be overwritten by installing a callback function which compares two records 
of the duplicate key. 

Such a compare function can be installed using the function @ref 
ham_set_duplicate_compare_func.

Here's the function declaration and the typedef declaration for a compare
function. 

\code
typedef int HAM_CALLCONV (*ham_duplicate_compare_func_t)(ham_db_t *db, 
                                  const ham_u8_t *lhs, ham_size_t lhs_length, 
                                  const ham_u8_t *rhs, ham_size_t rhs_length);

ham_status_t
(ham_db_t *db, ham_duplicate_compare_func_t foo);
\endcode

Sorting the duplicates comes with a small performance penalty compared 
to sequential inserts. 

\section tut_Working_with_Transactions    Working with Transactions

A Transaction is an atomic, consistent, isolated and durable ("ACID") unit 
of work. Transactions guarantee that all database operations of this 
Transactions are either all written to the database in one atomic 
"commit" or cancelled and undone in one atomic "abort". To read more about
Transactions, Wikipedia provides a good entry point:
<A  HREF="http://en.wikipedia.org/wiki/Database_transactions">http://en.wikipedia.org/wiki/Database_transactions</A>.
The following chapter describes the state of Transaction support in
hamsterdb, and gives a primer how to use them.




\subsection tut_Transaction_support_in_hamsterdb    Transaction support in hamsterdb Embedded Storage

hamsterdb Embedded Storage only offers limited
support for Transactions: there can only be one Transaction at a
time. If one Transaction is created with \ref ham_txn_begin,
a subsequent \ref ham_txn_begin will fail with \ref HAM_LIMITS_REACHED,
until the first Transaction is either aborted (with \ref ham_txn_abort)
or committed (with \ref ham_txn_commit).


This rule applies also for functions which create
their own temporary Transaction. These functions will fail, if
another Transaction is active. Consider the following snippet (error
handling omitted):


\code
ham_txn_t *txn;

// create a new transaction
ham_txn_begin(&txn, db, 0);

// insert an item WITHOUT a transaction &ndash; will fail!
ham_insert(db, 0, key, record, 0);
\endcode

The call to \ref ham_insert will create its own, temporary Transaction. 
The function will therefore fail with \ref HAM_LIMITS_REACHED.
The following functions create temporary Transactions, unless no
other Transaction was explicitely specified: \ref ham_insert,
\ref ham_find, \ref ham_erase and \ref ham_cursor_create.
The function \ref ham_env_erase_db will also create a temporary Transaction.

\subsection tut_Enabling_Transactions    Enabling Transactions

Transaction support has to be explicitely enabled with the 
flag \ref HAM_ENABLE_TRANSACTIONS when creating or opening an Environment 
or a Database. The support for Transactions comes with a certain cost 
regarding performance, because it implicitely enables logging/recovery. 
The following code enables the use of Transactions:

\code
st=ham_env_create(env, "test.db", HAM_ENABLE_TRANSACTIONS, 0644);
if (st!=HAM_SUCCESS) {
    printf("ham_env_create failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode


\subsection tut_Beginning_a_new_Transaction    Beginning a new Transaction

A new Transaction can be started with \ref ham_txn_begin.
The \c flags are unused and should be set to 0.


\code
ham_status_t 
ham_txn_begin(ham_txn_t **txn, ham_db_t *db, ham_u32_t flags) ;
\endcode

If Transactions were not enabled (with \ref HAM_ENABLE_TRANSACTIONS),
the function will return \ref HAM_INV_PARAMETER; if another Transaction 
is still active, \ref HAM_LIMITS_REACHED will be returned.


\subsection tut_Using_Transactions    Using Transactions

A Transaction can be used with the following functions: 


<UL>
	<LI>
	\ref ham_insert
	<LI>
	\ref ham_erase
	<LI>
	\ref ham_find
	<LI>
	\ref ham_cursor_create
</UL>

In all four cases, the second parameter is the Transaction handle. The 
following example illustrates how to insert an item with a 
transactional \ref ham_insert; the use of \ref ham_erase
and \ref ham_find is very similar. The changes to the Database are only 
written if the Transaction is committed! If it is aborted or the application
crashes, the changes are not written.

\code
ham_txn_t *txn; 

if ((st=ham_txn_begin(&txn, db, 0))) {
    printf("ham_txn_begin failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}

st=ham_insert(db, txn, key, record, 0);
if (st!=HAM_SUCCESS) {
    printf("ham_insert failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

In case of \ref ham_cursor_create,
the Cursor will be &quot;attached&quot; to the Transaction during
its whole lifetime. You have to close the Cursor before committing or
aborting the Transaction, otherwise the commit or abort fails with an
error.




\subsection tut_Committing_a_Transaction    Committing a Transaction

When committing a Transaction, it is written
atomically to the Database. The commit is fairly easy:


\code
ham_status_t 
ham_txn_commit(ham_txn_t *txn, ham_u32_t flags) ;
\endcode

Again, the flags are not yet used; set them to 0. 



\code
st=ham_txn_commit(txn, 0);
if (st!=HAM_SUCCESS) {
    printf("ham_txn_commit failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

As mentioned above, the commit will fail with \ref HAM_CURSOR_STILL_OPEN 
if there are still Cursors attached to this Transaction.




\subsection tut_Aborting_a_Transaction    Aborting a Transaction

When aborting  a Transaction, all changes are undone. Analog to the commit, 
aborting a Transaction is simple:


\code
ham_status_t 
ham_txn_abort(ham_txn_t *txn, ham_u32_t flags) ;
\endcode

Again, the flags are not yet used; set them to 0. 

\code
st=ham_txn_abort(txn, 0);
if (st!=HAM_SUCCESS) {
    printf("ham_txn_abort failed: %d (%s)\n", st, ham_strerror(st));
    exit(-1);
}
\endcode

As mentioned above, the abort will fail with \ref HAM_CURSOR_STILL_OPEN 
if there are still Cursors attached to this Transaction.


\section tut_Approximate_Matching    Approximate Matching

Starting with version 1.1.0, hamsterdb offers a functionality called 
"Approximate Matching". It allows you to look up values even if you do not
know their key!

Imagine an embedded system with a sensor attached. In irregular intervals,
the sensor returns a value which will then be stored in the database. Sometimes
it returns a value every second, in other moments it returns just one value per
minute.

hamsterdb is storing those values and uses the current timestamp as a key.

Further imagine that the application now wants to check the sensor value
at about 12:00 o'clock. Note the "about" - chances are low that there's a key
with the 12:00 o'clock timestamp. The application needs hamsterdb to retrieve
a value which was stored at 12:00 o'clock or <b>very close</b> to it!

Approximate Matching gives that functionality. You can ask hamsterdb to
retrieve values which match a key exactly or which are lower or greater than
this key, but still very close to it. 

You can do this by specifying a combination of the following flags to 
\ref ham_find or \ref ham_cursor_find:

<ul>
 <li>@ref HAM_FIND_EXACT_MATCH </li>. This is the default setting. 
     If the @a key exists, the record of this key will be returned.
 <li>@ref HAM_FIND_LT_MATCH </li> 'find' flag 'Less Than': retrieves 
     the last record with a key which is less than the specified key.
 <li>@ref HAM_FIND_GT_MATCH </li> 'find' flag 'Greater Than': retrieves
     the first record with a key which is greater than the specified key.
 <li>@ref HAM_FIND_LEQ_MATCH </li> 'find' flag 'Less or EQual': retrieves
     the last record with a key which is less or equal than the specified key.
 <li>@ref HAM_FIND_GEQ_MATCH </li> 'find' flag 'Greater or Equal': retrieves
     the first record with a key which is greater or equal than the 
     specified key.
 <li>@ref HAM_FIND_NEAR_MATCH </li> 'find' flag 'Any Near Or 
     Equal': retrieves the record which' key matches the specified key and 
     when such a key is not available hamsterdb will retrieve either the 
     last record which' key is less than the specified key or 
     the first record which' key is larger than the specified 
     key, whichever of these records is located first.
</ul>

Here's a short example snippet to search for a key or a "very close" key:

\code
memset(&record, 0, sizeof(record));
memset(&key, 0, sizeof(key));
/* fill key */

if ((st=ham_find(db, NULL, &key, &record, HAM_FIND_NEAR_MATCH))!=HAM_SUCCESS) {
    // ...
\endcode

\section tut_The_CPP_API    The C++ API

hamsterdb also provides a C++ wrapper class for
C++ developers. To use it, include \c <ham/hamsterdb.hpp>.
All classes are in the namespace \c ham:


\code 
#include <ham/hamsterdb.hpp>
using namespace ham;
\endcode

Each C++ class and method usually wraps one single
call to the C API. Therefore, the C++ API is only documented if the
behaviour differs from its C counterpart.


Currently, there are two samples using the C++
API: <I>samples/db6.cpp</I> and <I>samples/env3.cpp</I>.





\section tut_Troubleshooting   Troubleshooting

hamsterdb gives you the best troubleshooting
available &ndash; the source code. If you compile hamsterdb in Debug
mode (i.e. with <tt>./configure --enable-debug</tt> ), you can always use 
a debugger to step into the functions. 



But there's another way to get information about
hamsterdb internals, and this even works in Release mode: the debug
messages. They are printed to stderr not only when a hamsterdb
function encounters a serious error (i.e. when writing to the file,
or when opening a file failed), but also when an API function
receives invalid parameters. However, the later messages are not
shown in Release mode.


But you can overwrite the error handler to catch
ALL of the messages and handle them on your own, and then you will
also see the low-priority messages. The following Code installs such
an error hander:


\code
void
my_own_error_handler(int level, const char *message)
{
    printf("level %d: %s\n", level, message);
}

ham_set_errhandler(my_own_error_handler);
\endcode

If you now call a hamsterdb function with an
invalid combination of flags or other invalid parameters, you will
see a message printed to stdout.


*/

